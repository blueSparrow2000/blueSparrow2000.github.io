---
layout: post
title: "ML background"  # 페이지 타이틀
post-order: 4                               # (내 커스텀 변수) 같은 카테고리 내 정렬 순서
# comments: true
---

이 포스트는 '케라스 창시자에게 배우는 딥러닝 개정 2판'을 읽고 딥러닝의 기본에 대한 내용을 정리한 것이다.

# Manifold hypothesis

 <p align="center">
  <img src="https://github.com/user-attachments/assets/b8569d05-a584-419a-8d37-a2e526cb8f32" width="50%" height="50%" alt="default" />
  <br>
  <em>국소적으로 평면인 다양체</em>
</p>

'세상의 모든 데이터는 고차원 공간 안의 저차원 매니폴드 위에 존재한다'는 딥러닝의 근본적인 가정이다.

딥러닝은 데이터를 가장 잘 설명하는 곡면을 찾는다. 즉 데이터들이 어떤 구조를 가진 부드러운 곡면 위에 존재하므로 딥러닝을 사용하면 그 근사적인 구조를 데이터로부터 학습해 낼 수 있다는 것이다.
이 구조는 간단하고 저차원이어서 컴퓨터가 처리할 수 있다. 또한, 다양체는 연속적이기 때문에 데이터들을 보간(interpolation) 하여 그 구조를 근사적으로 만들어낼 수 있다.

예시로는 찌그러진 종이를 펴는 과정을 딥러닝에 자주 비유한다.
딥러닝에서 각 연산과 활성화 함수가 찌그러진 manifold를 평면으로 펼쳐 데이터 클래스 간 경계를 찾기 편하게 만든다는 것이다.

<br/>
  
# Training

<p align="center">
  <img src="https://github.com/user-attachments/assets/072b1bb2-4dfc-4df3-b888-258de756c37e" width="50%" height="50%" alt="default" />
</p>

딥러닝 모델을 학습시키는 과정이다. 주로 forward pass, back propagation으로 이루어져 있으며, 모델을 테스트할 때는 forward pass만 수행하면 된다.
학습 시에는 데이터로부터 표현을 학습하기 위해 예측과 개선을 반복한다.

Input을 모델에 넣어 예측값을 얻으면, 실제값 (레이블)과 차이를 계산하고, 역전파 알고리즘으로 모델의 가중치를 조절한다.

<br/>

# Back propagation
역전파라고도 하며, 예측값과 실제값의 차이를 계산하는 손실함수를 토대로 gradient를 계산한다.
딥러닝 모델의 있다.

<br/>

# Overfitting
딥러닝으로 문제를 해결할 때는 최적화(optimization)와 일반화(generalization)의 trade-off에 맞닥뜨리게 된다.
딥러닝은 훈련 과정에 사용한 데이터만으로 학습하기 때문에 처음 보는 데이터가 있을 수 밖에 없다.
처음 보는 데이터도 얼마나 잘 예측하는가가 모델의 일반화 성능, 훈련 과정에서 얼마나 잘 예측하느냐가 최적화 성능을 결정한다.
문제는 훈련 데이터가 해결하고자 하는 문제의 모든 데이터를 대표하지 못한다는 것이다.
따라서 훈련 데이터에 너무 최적화 시켜서 데이터에 따른 정답을 다 외워버릴 정도로 최적화하면 처음 보는 데이터는 제대로 예측하지 못할 것이고, 이는 일반화 성능저하로 이어진다.

적절한 훈련 정도를 찾기 위해 훈련데이터의 일부를 검증 데이터로 분리하여 마치 처음 보는 데이터인 양 모델의 일반화 성능을 검증하는데 사용할 수 있다.


<p align="center">
  <img src="https://github.com/user-attachments/assets/875265e4-bf75-4106-bf1c-3b9c6efac8d7" width="50%" height="50%" alt="default" />
</p>

최적적합은 최적화와 일반화가 모두 잘 되었을 때를 말한다. 최적적합에 도달하려면 훈련 손실은 계속 감소하는데 검증 손실이 증가해야 한다.
즉, 훈련데이터에 과도하게 학습되어 봐야 언제 멈춰야 하는지 알 수 있고, 이때 과대적합 된 상태를 overfitting 되었다고 한다.

<br/>
그런데 문제가 쉬운 선형 관계로 되어있고 훈련데이터가 오차가 없어 데이터를 너무 잘 대표한다면 과대적합이 일어나지 않을 것이다.
검증 손실이 훈련 손실과 같이 감소하기만 할 것이기 때문이다.

그러나 현실의 데이터로 학습하면 과적합이 일어나기 부지기수다.
아래처럼 훈련데이터의 본질적인 문제들이 있기 때문이다.

- 잘못 라벨링 된 데이터 (훈련데이터에 섞인 경우)
- 의미 없거나 이상한 데이터
- 문제 자체에 불확실한 영역이 존재할 경우
- 드문 특성으로 인한 가짜 상관관계

이런 이유로 훈련 과정에서 과적합은 발생하며, 모델은 과대적합 점을 찾아 그 전까지만 학습시키도록 하는 게 일반화 성능을 높이기 좋다.




